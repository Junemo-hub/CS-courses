🧠 강의 개요
강의 제목: Introduction to Algorithms
강사: Jason Ku + Eric Demaine, Justin Solomon (협업 강의)

🎯 이 강의의 목표
1. 계산 문제 해결 방법 학습
2. 정당성 증명(prove correctness)
3. 효율성 분석(argue efficiency)
4. 명확한 커뮤니케이션 훈련

단순 구현보다 아이디어 전달 능력에 초점

글쓰기 많이 함 (코딩보다 글이 많음)

📌 핵심 개념 요약
1. 문제(Problem)란?
입력 집합과 출력 집합 사이의 이진 관계

입력 → 가능한 출력 중 하나 이상 매칭 가능 (예: 배열에서 5의 인덱스 찾기)

2. 알고리즘(Algorithm)이란?
임의의 입력을 받아 정답 출력으로 매핑하는 함수

정확한 출력만 반환해야 함 (정확도 중요)

🧪 예시: 생일 문제 (Birthday Problem)
문제: 같은 생일을 가진 학생이 있는지 확인
제안된 알고리즘:

학생을 순서대로 인터뷰

생일이 기록에 있는지 확인

있다면 → 쌍 반환

없다면 → 기록에 추가 후 다음으로

정당성 증명 방법:

귀납법(induction) 사용:

기초 사례(base case): 학생 0명 → 충돌 없음

귀납 가정(hypothesis): 처음 K명 중에 쌍 있으면 이미 반환됨

귀납 단계(inductive step): K+1번째 학생 확인 → 쌍 있으면 반환

⏱ 효율성(Efficiency)이란?
단순한 실행 시간보다 입력 크기와의 관계가 중요

시간을 측정하지 말고, 연산 횟수(기본 연산 수)를 셈

모델: Word RAM (CPU는 고정 크기의 word만 연산)

📊 시간 복잡도 함수 예시
종류	함수	의미
상수 시간	O(1)	입력과 무관
로그 시간	O(log n)	이진 탐색 등
선형 시간	O(n)	전체 탐색
로그선형	O(n log n)	효율적인 정렬 알고리즘
2차 시간	O(n²)	중첩 루프
지수 시간	O(2ⁿ)	매우 비효율적

효율적인 알고리즘: 보통 다항 시간(polynomial time) 이내

💻 연산 모델: Word RAM
RAM (Random Access Memory): 메모리를 일정 시간에 임의 접근 가능

Word: CPU가 한 번에 연산 가능한 고정 크기 비트 묶음 (예: 64-bit)

연산: 두 word를 가져와서 연산 → word로 결과 저장

📦 이후 수업 구성
주제	기간
데이터 구조 & 정렬	1~8강
그래프 & 최단 경로	중간 퀴즈 후
동적 계획법 (DP)	마지막 파트

📚 수업 방식 요약
직접 알고리즘 설계 또는 기존 문제로 환원(reduction)

귀납법, 재귀(recursion) 중심 접근

정확성 + 효율성 + 설명 가능성에 집중

