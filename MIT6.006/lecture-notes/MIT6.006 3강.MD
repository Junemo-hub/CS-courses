# ğŸ“˜ MIT 6.006 Lecture 3 ìš”ì•½: Sorting

## ğŸ“š Set ì¸í„°í˜ì´ìŠ¤ì™€ ë°°ì—´ ê¸°ë°˜ êµ¬í˜„

### Set ì¸í„°í˜ì´ìŠ¤ ì—°ì‚°
| ì—°ì‚° | ì„¤ëª… |
|------|------|
| `build(X)` | iterable Xë¡œë¶€í„° set ìƒì„± |
| `len()` | ì €ì¥ëœ í•­ëª© ê°œìˆ˜ ë°˜í™˜ |
| `find(k)` | í‚¤ê°€ kì¸ í•­ëª© ë°˜í™˜ |
| `insert(x)` | í•­ëª© ì¶”ê°€ (ê¸°ì¡´ í‚¤ë©´ ëŒ€ì²´) |
| `delete(k)` | í‚¤ê°€ kì¸ í•­ëª© ì‚­ì œ |
| `find_min()` / `find_max()` | ìµœì†Œ/ìµœëŒ€ í‚¤ í•­ëª© ë°˜í™˜ |
| `find_next(k)` / `find_prev(k)` | kë³´ë‹¤ í°/ì‘ì€ í‚¤ ì¤‘ ê°€ì¥ ê°€ê¹Œìš´ í•­ëª© ë°˜í™˜ |

### ë°°ì—´ ê¸°ë°˜ êµ¬í˜„ ë¹„êµ

| ìë£Œêµ¬ì¡° | `find` | `insert` | `delete` | `find_min/max` |
|----------|--------|-----------|------------|-----------------|
| Unsorted Array | O(n) | O(n) | O(n) | O(n) |
| **Sorted Array** | **O(log n)** | O(n) | O(n) | **O(1)** |

---

buildë¥¼ í•˜ëŠ” ë°ì—ëŠ” n*log(n) ë“±ìœ¼ë¡œ ì‹œê°„ì´ ì¢€ ë” ê±¸ë ¸ë˜ ê²ƒ ê°™ìŒ.

## ğŸ”€ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜

### 1. ğŸŒ€ Permutation Sort
- **ì•„ì´ë””ì–´**: ëª¨ë“  ìˆœì—´ì„ íƒìƒ‰í•´ ì •ë ¬ ì—¬ë¶€ í™•ì¸
- **ì‹œê°„ ë³µì¡ë„**: Î©(n! Â· n)
- **ë¹„ê³ **: ë¹„íš¨ìœ¨ì  ë¸Œë£¨íŠ¸ í¬ìŠ¤

```python
from itertools import permutations

def permutation_sort(A):
    for B in permutations(A):
        if is_sorted(B):
            return B


2. ğŸ§© Selection Sort
ì•„ì´ë””ì–´: ìµœëŒ€ê°’ì„ ë’¤ë¡œ ë³´ë‚´ë©° ì •ë ¬
ì‹œê°„ ë³µì¡ë„: Î˜(nÂ²)
ê³µê°„ ë³µì¡ë„: O(1) (ì œìë¦¬ ì •ë ¬)

def selection_sort(A, i=None):
    if i is None: i = len(A) - 1
    if i > 0:
        j = prefix_max(A, i)
        A[i], A[j] = A[j], A[i]
        selection_sort(A, i - 1)

def prefix_max(A, i):
    if i > 0:
        j = prefix_max(A, i - 1)
        return j if A[j] > A[i] else i
    return i

3. ğŸ” Insertion Sort
ì•„ì´ë””ì–´: ì•ë¶€ë¶„ì„ ì •ë ¬ëœ ìƒíƒœë¡œ ìœ ì§€í•˜ë©´ì„œ ì‚½ì…
ì‹œê°„ ë³µì¡ë„: Î˜(nÂ²)
ê³µê°„ ë³µì¡ë„: O(1) (ì œìë¦¬ ì •ë ¬)

def insertion_sort(A, i=None):
    if i is None: i = len(A) - 1
    if i > 0:
        insertion_sort(A, i - 1)
        insert_last(A, i)

def insert_last(A, i):
    if i > 0 and A[i] < A[i - 1]:
        A[i], A[i - 1] = A[i - 1], A[i]
        insert_last(A, i - 1)


4. ğŸŒŠ Merge Sort
ì•„ì´ë””ì–´: ë°°ì—´ì„ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì •ë ¬í•œ ë’¤ ë³‘í•© (Two-finger merge)
ì‹œê°„ ë³µì¡ë„: Î˜(n log n)
ê³µê°„ ë³µì¡ë„: Î˜(n) (ë¹„ì œìë¦¬ ì •ë ¬)

def merge_sort(A, a=0, b=None):
    if b is None: b = len(A)
    if 1 < b - a:
        c = (a + b + 1) // 2
        merge_sort(A, a, c)
        merge_sort(A, c, b)
        L, R = A[a:c], A[c:b]
        merge(L, R, A, len(L), len(R), a, b)

def merge(L, R, A, i, j, a, b):
    if a < b:
        if j <= 0 or (i > 0 and L[i - 1] > R[j - 1]):
            A[b - 1] = L[i - 1]
            merge(L, R, A, i - 1, j, a, b - 1)
        else:
            A[b - 1] = R[j - 1]
            merge(L, R, A, i, j - 1, a, b - 1)

ğŸ“ ì¬ê·€ ë¶„ì„ ê¸°ë²•
Substitution Method: í•´ë¥¼ ì¶”ì¸¡í•˜ê³  ëŒ€ì…í•´ ì¦ëª…
Recurrence Tree: í˜¸ì¶œ êµ¬ì¡°ë¥¼ íŠ¸ë¦¬ë¡œ ê·¸ë ¤ í•©ì‚°
Master Theorem: T(n) = aT(n/b) + f(n) í˜•íƒœë¥¼ í•´ê²°í•˜ëŠ” ê³µì‹


| ì•Œê³ ë¦¬ì¦˜             | ì‹œê°„ ë³µì¡ë„     | ê³µê°„ ë³µì¡ë„ | ì œìë¦¬ ì •ë ¬ | ì•ˆì •ì„± |
| ---------------- | ---------- | ------ | ------ | --- |
| Permutation Sort | O(n! Â· n)  | O(n)   | âŒ      | âœ…   |
| Selection Sort   | O(nÂ²)      | O(1)   | âœ…      | âŒ   |
| Insertion Sort   | O(nÂ²)      | O(1)   | âœ…      | âœ…   |
| Merge Sort       | O(n log n) | O(n)   | âŒ      | âœ…   |

